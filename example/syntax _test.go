//@Title 基础语法
package example

// # 1. 值类型和引用类型
//   值类型：数组，结构。
//   引用类型：切片、字典、通道、接口、函数。
//
//
// # 2. range
//   range表达式返回的是对象的副本，并且计算计算一次。也就是说，可以一边增/删/改，一边遍历。
//
//
// # 3. switch
//   switch的缺省行为和c++不同，一旦某个case子句被选中，其他的所有case子句都会被忽略。如果希望fallthrough，需要明确声明。
//
//
// # 4. func
//   函数是一等的公民，这意味着函数可以被自由传播。由此，可以编写出高阶函数，也就是函数的输入或输出类型是也是函数，它比接口更灵活。
//   Go语言支持闭包函数。
//
//
// # 5. struct
// 1)指针方法
//   值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。
// 而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。
//   一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。
//
// 2)嵌入
//   Go语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段。
// 嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，但被嵌入类型的字段或方法会“屏蔽”掉嵌入字段的同名字段和方法，无论它们的类型是否相同。
// 我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段或方法。也就是说，嵌入字段的类型既是类型也是名称。
//
//   发生多层嵌入时，如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个编译错误，因为编译器无法确定被选择的成员到底是哪一个。
//
// 3)组合 vs 继承
//   类型组合是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。
// 如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。
//
// 4)struct {} 空结构体类型变量不占内存空间，内存地址相同，常用于在通道里传递“信号”。
//
//
// # 6. interface
//   接口本身也是一种类型，它代表的是一个方法的集合。任何类型只要实现了接口中声明的所有方法，那么该类就实现了该接口。
//与其他语言不同，golang并不需要显示声明类型实现了某个接口，而是由编译器和runtime进行检查。不用显示什么这点非常棒，这样就无侵入非常方便。
//   接口的值简单来说，是由两部分组成的，就是类型和数据。判断两个接口是相等，就是看他们的这两部分是否相等；另外类型和数据都为nil才代表接口是nil。
//   接口类型可以通过嵌入的方式进行组合，不过不同于struct的嵌入，不存在名称屏蔽，只要有相同名字的方法，编译就会报错。
// Go语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。
// Go语言的接口必须在字面上严格匹配，不会进行泛型化推导。
// 参考：
//   go官方博客：http://golang.org/blog/laws-of-reflection, http://golang.org/doc/faq
//   剖析golang interface实现： https://www.jianshu.com/p/5f8ecbe4f6af
//
//
// # 7. pointer
//   Go内建类型uintptr实质上是一个数值类型，用来指涉原始内存地址。
//   Go语言还提供了直接操作“内存”的类C指针，它们在unsafe包中提供，包含Pointer、SizeOf、OffsetOf、AlignOf等类C的用法。
//   unsafe.Pointer可以表示任何指向可寻址的值的指针，通过它，我们可以在指针值和unitptr之间进行双向转换。
//
//
// # 8. 通道
//   select语句是专门为通道而设计的，它可以包含若干个后续分支：
//     - 当没有通道可读时会阻塞，除非有default分支；
//     - 当多个通道可读，则随机选择一个case分支执行；
//   如果在select语句中发现某个通道已关闭，那么应该怎样屏蔽它所在的分支？把通道置为nil即可。
//   参考：Go Concurrency Patterns: Timing out, moving on,  https://blog.golang.org/go-concurrency-patterns-timing-out-and
//
//
// # 9. 数组 和 切片
//   1)Go语言数组类似于C++的容器Array，固定长度、连续的内存区域、索引访问，最重要的是“值传递”。
//
//   2)切片
//    切片是对底层数组的引用，是访问底层数组的一个窗口。
//    除了使用make建立切片，我们还可以基于现有的数组显式创建切片，例如，
//        var tmp [256]byte // Storage for slice.
//        slice := tmp[0,200]
//    切片的底层数组什么时候会被替换？
//        确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。
//    它是把新的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。
//        请记住，在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。
//    注意，当我们要取得一份底层数据“拷贝”时，应当使用copy操作，而不是slice赋值。
//    注意，从一个切片生成新的切片slice[0:n]，初始时两个切片指向相同的底层数组，但当对一个切片做操作导致底层数组需要扩容时，两个切片将指向不同的底层数组。
//    注意，切片的特征决定了：
//        1）当我们想删除切片中的元素的时候，会造成大量的元素的移动(复制).
//        2）在切片被频繁”扩容“的情况下，新的底层数组不断产生，内存分配以及元素复制会对程序的性能产生负面的影响。
//        3）当我们没有一个合理、有效的“缩容”策略的时候，底层数组中会有大量无用的元素槽位。
//
//    关于切片的描述，参考golang官方博客：http://golang.org/blog/go-slices-usage-and-internals
//
//
// # 10. 字典
// 1)字典的键类型不能是哪些类型？
//   典型答案：Go语言字典的键类型不可以是函数类型、字典类型和切片类型。
//   Go语言字典是哈希表的一个特定实现，为了处理“哈希碰撞”，要求键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值不支持判等操作，所以字典的键类型不能是这些类型。
//   另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发panic。
//   还要注意，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。
//
// 2)应该优先考虑哪些类型作为字典的键类型？
//   从性能的角度看，键值哈希和判等明显是两个重要且比较耗时的操作。因此，可以说，求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。
//   对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。
//   以求哈希的操作为例，宽度越小的类型速度通常越快。对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定。
//   不建议使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在他们的值中存在变数。比如，对一个数组来说，我可以任意改变其中的元素值，但在变化前后，它却代表了两个不同的键值。
//   对于结构体类型的值情况可能会好一些，因为如果我可以控制其中各字段的访问权限的话，就可以阻止外界修改它了。
//   把接口类型作为字典的键类型最危险。如果在这种情况下 Go运行时系统发现某个键值不支持判等操作，那么就会立即抛出一个panic。在最坏的情况下，这足以使程序崩溃。
//   那么，在那些基本类型中应该优先选择哪一个？答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。
//
// 3)在值为nil的字典上执行读操作会成功吗，那写操作呢？
//   由于字典是引用类型，所以当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是nil。
//   除了添加键-元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键-元素对的时候，Go 语言的运行时系统就会立即抛出一个panic。