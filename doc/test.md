# Go 测试

## FAQ

### 1. 测试基本用法

    go test 缺省执行所有功能和示例测试函数，不执行性能测试，用法：
      - go test 执行当前代码包下的功能和示例测试;
      - go test package 执行指定代码包下的功能和示例测试; 
      - go test xx_test.go 执行demo_test.go文件中的功能和示例测试;

    常用参数：
      -bench regexp 执行相应的 benchmarks，例如 -bench=.;
      -run regexp 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数;
      -v 显示测试的详细命令;
      -cover 开启测试覆盖率;
      -count 指定执行次数，这会禁用缓存;      
      -parallel 设置同一个被测代码包中的功能测试函数的最大并发执行数，该标记的默认值是测试运行时的最大P数量。 对性能测试无效。

    单元测试：对单一的功能模块进行边界清晰的测试，并且不掺杂任何对外部环境的检测。这也是“单元”二字要表达的主要含义。
    性能测试：常常需要反复地执行，并以此试图抹平当时的计算资源调度的细微差别对被测程序性能的影响。通过-cpu标记，我们还能够模拟被测
             程序在计算能力不同计算机中的性能表现。


注: 系统测试也可以统计覆盖率，参考 [Code Coverage for your Golang System Tests](https://www.elastic.co/cn/blog/code-coverage-for-your-golang-system-tests)。

### 2. 如何执行基准测试？

#### 2.1 基准测试原理

    基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么
    testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。

#### 2.2 自定义测试时间

    通过-benchtime参数可以自定义测试时间，例如：
      $ go test -v -bench=. -benchtime=5s benchmark_test.go

#### 2.3 测试内存

    基准测试可以对一段代码可能存在的内存分配进行统计，在命令行中添加-benchmem参数以显示内存分配情况：
      go test -v -bench=Alloc -benchmem benchmark_test.go

#### 2.4 控制计时器

所谓的计时器，是一个逻辑上的概念，它其实是testing.B类型中一些字段的统称。这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。

    有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。
    testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。

    func Benchmark_Add_TimerControl(b *testing.B) {
      // 重置计时器
      b.ResetTimer()

      // 停止计时器
      b.StopTimer()

      // 开始计时器
      b.StartTimer()

      var n int
      for i := 0; i < b.N; i++ {
        n++
      }
    }

#### 2.5 控制并发

    Go语言并发模型MPG:
      P 是 Prrocessor 逻辑处理器，每个P都是一个可以承载若干个G。
      G 是 goroutine。
      M 即为 machine 的缩写，代表着系统级线程。

    P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在。
    
    每一个队列都相当于一条流水线，它会源源不断地把可运行的 G 输送给空闲的 M，并使这两者对接。一旦对接完成，被对接的 G 就真正地运行
    在操作系统的内核级线程之上了。每条流水线之间虽然会有联系，但都是独立运作的。
    
    因此，最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数。

    在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量。当然了，前者也可以大于或者小于后者，如此可以在一定程度上模拟拥有
    不同的 CPU 核心数的计算机。

    所以，也可以说，使用-cpu标记可以模拟：被测程序在计算能力不同计算机中的表现，
       -cpu=1,2,4

    如果没有指定 -cpu 参数，那么就会让逻辑 CPU 只包含一个元素值，即最大 P 数量的默认值，也就是当前计算机 CPU 核心的实际数量。